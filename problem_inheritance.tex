\subsection{Семинар <<Конструкторы, наследование и полиморфизм. 1 часть>>  
(2 часа)}


В ходе работы решите 4 задачи. 
Предполагается, что пользователь класса не имеет права обращаться к свойствам напрямую 
(соблюдая принцип инкапсуляции), а должен использовать методы. 

Продемонстрируйте работоспособность всех методов (из задания) 
посредством создания запускаемых файлов, где осуществляется 
вызов методов для разных ситуаций 
(без ручного ввода, но с выводом результатов в консоль). 

Каждый класс должен сохраняться в отдельном исходном файле. 
Необходимо соблюдать все стандартные требования к качеству кода 
(отступы, именования переменных, классов, методов, 
проверка корректности входных данных).
Для каждого класса создайте отдельный запускаемый файл для проверки всех его методов 
(допускается использование других классов в этих тестах).

Все предлагаемые классы в заданиях упрощенные; для использования в production-окружении они требуют серьезной доработки. Суть задания — в отработке базовых навыков, а не в идеальном моделировании предложенных ситуаций.

Для сдачи работы будьте готовы пояснить или аналогично заданию модифицировать любую часть кода, а также ответить на вопросы:
\begin{enumerate}
    \item Что обозначает свойство наследования в парадигме ООП?
    \item Что обозначает свойство полиморфизма в парадигме ООП?
    \item Опишите реализацию наследования в Python
    \item Как создать конструктор в Python
    \item Как реализовать абстрактный класс в Python (и что это значит)
    \item Как реализовать абстрактные методы в Python (и что это значит)
\end{enumerate}

Если вы нашли в задачнике ошибки, опечатки и другие недостатки, то вы можете сделать pull-request. 

\textbf{Срок сдачи работы (начала сдачи):} через одно занятие после его выдачи. В последующие сроки оценка будет снижаться (при отсутствии оправдывающих документов).

\textbf{Задача 1}

\input{problem_inheritance_task1}

\textbf{Задача 2}

\begin{enumerate}
    \item

Написать программу, которая создаёт класс \texttt{LeapYearChecker} 
для определения високосного года. В классе должен быть статический метод
\texttt{is\_leap\_year} и возвращать \texttt{True}, если год високосный, 
и \texttt{False} в противном случае. 
Программа также должна использовать цикл для проверки каждого года от 
2000 до 2099 и вывода результата на экран.

\subsection*{Инструкции:}
\begin{enumerate}
    \item Создайте класс \texttt{LeapYearChecker}.
    \item Создайте \textbf{статический} метод \texttt{is\_leap\_year}, который принимает год в качестве аргумента и проверяет, является ли год високосным. Если год делится на 4 без остатка и не делится на 100 без остатка, или делится на 400 без остатка, то возвращает \texttt{True}. В противном случае возвращает \texttt{False}.
    \item Используйте цикл для проверки каждого года от 2000 до 2099 (включительно), вызывая статический метод \texttt{is\_leap\_year} и выводя результат на экран.
\end{enumerate}

\subsection*{Пример использования:}
\begin{lstlisting}[language=Python]
    v = LeapYearChecker.is_leap_year(1999)
\end{lstlisting}
Вывод (первые и последние строки):
\begin{verbatim}
2000 True
2001 False
...
2098 False
2099 False
\end{verbatim}

\item
Написать программу, которая создаёт класс \texttt{PrimeChecker} 
для определения простого числа. В классе должен быть статический метод
\texttt{is\_prime} и возвращать \texttt{True}, если число простое, 
и \texttt{False} в противном случае. 
Программа также должна использовать цикл для проверки каждого числа от 
1 до 100 и вывода результата на экран.

\subsection*{Инструкции:}
\begin{enumerate}
    \item Создайте класс \texttt{PrimeChecker}.
    \item Создайте \textbf{статический} метод \texttt{is\_prime}, который принимает число в качестве аргумента и проверяет, является ли число простым. Простое число делится только на 1 и на само себя.
    \item Используйте цикл для проверки каждого числа от 1 до 100 (включительно), вызывая статический метод \texttt{is\_prime} и выводя результат на экран.
\end{enumerate}

\subsection*{Пример использования:}
\begin{lstlisting}[language=Python]
    v = PrimeChecker.is_prime(17)
\end{lstlisting}
Вывод (первые и последние строки):
\begin{verbatim}
1 False
2 True
3 True
...
98 False
99 False
100 False
\end{verbatim}

\item
Написать программу, которая создаёт класс \texttt{EvenChecker} 
для определения чётности числа. В классе должен быть статический метод
\texttt{is\_even} и возвращать \texttt{True}, если число чётное, 
и \texttt{False} в противном случае. 
Программа также должна использовать цикл для проверки каждого числа от 
1 до 50 и вывода результата на экран.

\subsection*{Инструкции:}
\begin{enumerate}
    \item Создайте класс \texttt{EvenChecker}.
    \item Создайте \textbf{статический} метод \texttt{is\_even}, который принимает число в качестве аргумента и проверяет, является ли число чётным.
    \item Используйте цикл для проверки каждого числа от 1 до 50 (включительно), вызывая статический метод \texttt{is\_even} и выводя результат на экран.
\end{enumerate}

\subsection*{Пример использования:}
\begin{lstlisting}[language=Python]
    v = EvenChecker.is_even(25)
\end{lstlisting}
Вывод (первые и последние строки):
\begin{verbatim}
1 False
2 True
3 False
...
48 True
49 False
50 True
\end{verbatim}

\item
Написать программу, которая создаёт класс \texttt{SquareChecker} 
для определения квадратного числа. В классе должен быть статический метод
\texttt{is\_square} и возвращать \texttt{True}, если число является квадратом целого числа, 
и \texttt{False} в противном случае. 
Программа также должна использовать цикл для проверки каждого числа от 
1 до 100 и вывода результата на экран.

\subsection*{Инструкции:}
\begin{enumerate}
    \item Создайте класс \texttt{SquareChecker}.
    \item Создайте \textbf{статический} метод \texttt{is\_square}, который принимает число в качестве аргумента и проверяет, является ли число квадратом целого числа.
    \item Используйте цикл для проверки каждого числа от 1 до 100 (включительно), вызывая статический метод \texttt{is\_square} и выводя результат на экран.
\end{enumerate}

\subsection*{Пример использования:}
\begin{lstlisting}[language=Python]
    v = SquareChecker.is_square(36)
\end{lstlisting}
Вывод (первые и последние строки):
\begin{verbatim}
1 True
2 False
3 False
...
99 False
100 True
\end{verbatim}

\item
Написать программу, которая создаёт класс \texttt{FactorialCalculator} 
для вычисления факториала числа. В классе должен быть статический метод
\texttt{factorial} и возвращать факториал числа. 
Программа также должна использовать цикл для вычисления факториала каждого числа от 
1 до 10 и вывода результата на экран.

\subsection*{Инструкции:}
\begin{enumerate}
    \item Создайте класс \texttt{FactorialCalculator}.
    \item Создайте \textbf{статический} метод \texttt{factorial}, который принимает число в качестве аргумента и возвращает его факториал.
    \item Используйте цикл для вычисления факториала каждого числа от 1 до 10 (включительно), вызывая статический метод \texttt{factorial} и выводя результат на экран.
\end{enumerate}

\subsection*{Пример использования:}
\begin{lstlisting}[language=Python]
    v = FactorialCalculator.factorial(5)
\end{lstlisting}
Вывод (первые и последние строки):
\begin{verbatim}
1 1
2 2
3 6
...
9 362880
10 3628800
\end{verbatim}

\item
Написать программу, которая создаёт класс \texttt{PalindromeChecker} 
для определения палиндрома числа. В классе должен быть статический метод
\texttt{is\_palindrome} и возвращать \texttt{True}, если число является палиндромом, 
и \texttt{False} в противном случае. 
Программа также должна использовать цикл для проверки каждого числа от 
100 до 200 и вывода результата на экран.

\subsection*{Инструкции:}
\begin{enumerate}
    \item Создайте класс \texttt{PalindromeChecker}.
    \item Создайте \textbf{статический} метод \texttt{is\_palindrome}, который принимает число в качестве аргумента и проверяет, является ли число палиндромом (читается одинаково слева направо и справа налево).
    \item Используйте цикл для проверки каждого числа от 100 до 200 (включительно), вызывая статический метод \texttt{is\_palindrome} и выводя результат на экран.
\end{enumerate}

\subsection*{Пример использования:}
\begin{lstlisting}[language=Python]
    v = PalindromeChecker.is_palindrome(121)
\end{lstlisting}
Вывод (первые и последние строки):
\begin{verbatim}
100 False
101 True
102 False
...
199 False
200 False
\end{verbatim}

\item
Написать программу, которая создаёт класс \texttt{ArmstrongChecker} 
для определения числа Армстронга. В классе должен быть статический метод
\texttt{is\_armstrong} и возвращать \texttt{True}, если число является числом Армстронга, 
и \texttt{False} в противном случае. 
Программа также должна использовать цикл для проверки каждого числа от 
100 до 500 и вывода результата на экран.

\subsection*{Инструкции:}
\begin{enumerate}
    \item Создайте класс \texttt{ArmstrongChecker}.
    \item Создайте \textbf{статический} метод \texttt{is\_armstrong}, который принимает число в качестве аргумента и проверяет, является ли число числом Армстронга (сумма цифр в степени, равной количеству цифр, равна самому числу).
    \item Используйте цикл для проверки каждого числа от 100 до 500 (включительно), вызывая статический метод \texttt{is\_armstrong} и выводя результат на экран.
\end{enumerate}

\subsection*{Пример использования:}
\begin{lstlisting}[language=Python]
    v = ArmstrongChecker.is_armstrong(153)
\end{lstlisting}
Вывод (первые и последние строки):
\begin{verbatim}
100 False
101 False
102 False
...
499 False
500 False
\end{verbatim}

\item
Написать программу, которая создаёт класс \texttt{PerfectNumberChecker} 
для определения совершенного числа. В классе должен быть статический метод
\texttt{is\_perfect} и возвращать \texttt{True}, если число является совершенным, 
и \texttt{False} в противном случае. 
Программа также должна использовать цикл для проверки каждого числа от 
1 до 1000 и вывода результата на экран.

\subsection*{Инструкции:}
\begin{enumerate}
    \item Создайте класс \texttt{PerfectNumberChecker}.
    \item Создайте \textbf{статический} метод \texttt{is\_perfect}, который принимает число в качестве аргумента и проверяет, является ли число совершенным (сумма делителей равна числу).
    \item Используйте цикл для проверки каждого числа от 1 до 1000 (включительно), вызывая статический метод \texttt{is\_perfect} и выводя результат на экран.
\end{enumerate}

\subsection*{Пример использования:}
\begin{lstlisting}[language=Python]
    v = PerfectNumberChecker.is_perfect(28)
\end{lstlisting}
Вывод (первые и последние строки):
\begin{verbatim}
1 False
2 False
3 False
...
998 False
999 False
1000 False
\end{verbatim}

\item
Написать программу, которая создаёт класс \texttt{FibonacciChecker} 
для проверки числа Фибоначчи. В классе должен быть статический метод
\texttt{is\_fibonacci} и возвращать \texttt{True}, если число является числом Фибоначчи, 
и \texttt{False} в противном случае. 
Программа также должна использовать цикл для проверки каждого числа от 
1 до 100 и вывода результата на экран.

\subsection*{Инструкции:}
\begin{enumerate}
    \item Создайте класс \texttt{FibonacciChecker}.
    \item Создайте \textbf{статический} метод \texttt{is\_fibonacci}, который принимает число в качестве аргумента и проверяет, является ли число числом Фибоначчи.
    \item Используйте цикл для проверки каждого числа от 1 до 100 (включительно), вызывая статический метод \texttt{is\_fibonacci} и выводя результат на экран.
\end{enumerate}

\subsection*{Пример использования:}
\begin{lstlisting}[language=Python]
    v = FibonacciChecker.is_fibonacci(21)
\end{lstlisting}
Вывод (первые и последние строки):
\begin{verbatim}
1 True
2 True
3 True
...
98 False
99 False
100 False
\end{verbatim}

\item
Написать программу, которая создаёт класс \texttt{PowerOfTwoChecker} 
для проверки степени двойки. В классе должен быть статический метод
\texttt{is\_power\_of\_two} и возвращать \texttt{True}, если число является степенью двойки, 
и \texttt{False} в противном случае. 
Программа также должна использовать цикл для проверки каждого числа от 
1 до 128 и вывода результата на экран.

\subsection*{Инструкции:}
\begin{enumerate}
    \item Создайте класс \texttt{PowerOfTwoChecker}.
    \item Создайте \textbf{статический} метод \texttt{is\_power\_of\_two}, который принимает число в качестве аргумента и проверяет, является ли число степенью двойки.
    \item Используйте цикл для проверки каждого числа от 1 до 128 (включительно), вызывая статический метод \texttt{is\_power\_of\_two} и выводя результат на экран.
\end{enumerate}

\subsection*{Пример использования:}
\begin{lstlisting}[language=Python]
    v = PowerOfTwoChecker.is_power_of_two(64)
\end{lstlisting}
Вывод (первые и последние строки):
\begin{verbatim}
1 True
2 True
3 False
...
127 False
128 True
\end{verbatim}

\item
Написать программу, которая создаёт класс \texttt{SumOfDigitsCalculator} 
для вычисления суммы цифр числа. В классе должен быть статический метод
\texttt{sum\_of\_digits} и возвращать сумму цифр. 
Программа также должна использовать цикл для вычисления суммы цифр каждого числа от 
1 до 50 и вывода результата на экран.

\subsection*{Инструкции:}
\begin{enumerate}
    \item Создайте класс \texttt{SumOfDigitsCalculator}.
    \item Создайте \textbf{статический} метод \texttt{sum\_of\_digits}, который принимает число в качестве аргумента и возвращает сумму его цифр.
    \item Используйте цикл для вычисления суммы цифр каждого числа от 1 до 50 (включительно), вызывая статический метод \texttt{sum\_of\_digits} и выводя результат на экран.
\end{enumerate}

\subsection*{Пример использования:}
\begin{lstlisting}[language=Python]
    v = SumOfDigitsCalculator.sum_of_digits(123)
\end{lstlisting}
Вывод (первые и последние строки):
\begin{verbatim}
1 1
2 2
3 3
...
49 13
50 5
\end{verbatim}

\item
Написать программу, которая создаёт класс \texttt{PrimeSumCalculator} 
для вычисления суммы простых чисел в диапазоне. В классе должен быть статический метод
\texttt{sum\_of\_primes} и возвращать сумму простых чисел в заданном диапазоне. 
Программа также должна использовать цикл для вычисления суммы простых чисел от 
1 до 100 и вывода результата на экран.

\subsection*{Инструкции:}
\begin{enumerate}
    \item Создайте класс \texttt{PrimeSumCalculator}.
    \item Создайте \textbf{статический} метод \texttt{sum\_of\_primes}, который принимает два аргумента (начало и конец диапазона) и возвращает сумму простых чисел в этом диапазоне.
    \item Используйте метод для вычисления суммы простых чисел от 1 до 100 и выведите результат.
\end{enumerate}

\subsection*{Пример использования:}
\begin{lstlisting}[language=Python]
    v = PrimeSumCalculator.sum_of_primes(1, 10)
\end{lstlisting}
Вывод:
\begin{verbatim}
Сумма простых чисел от 1 до 100: 1060
\end{verbatim}

\item
Написать программу, которая создаёт класс \texttt{DigitCountCalculator} 
для подсчёта количества цифр в числе. В классе должен быть статический метод
\texttt{digit\_count} и возвращать количество цифр. 
Программа также должна использовать цикл для подсчёта цифр каждого числа от 
1 до 100 и вывода результата на экран.

\subsection*{Инструкции:}
\begin{enumerate}
    \item Создайте класс \texttt{DigitCountCalculator}.
    \item Создайте \textbf{статический} метод \texttt{digit\_count}, который принимает число в качестве аргумента и возвращает количество его цифр.
    \item Используйте цикл для подсчёта цифр каждого числа от 1 до 100 (включительно), вызывая статический метод \texttt{digit\_count} и выводя результат на экран.
\end{enumerate}

\subsection*{Пример использования:}
\begin{lstlisting}[language=Python]
    v = DigitCountCalculator.digit_count(12345)
\end{lstlisting}
Вывод (первые и последние строки):
\begin{verbatim}
1 1
2 1
3 1
...
99 2
100 3
\end{verbatim}

\item
Написать программу, которая создаёт класс \texttt{BinaryConverter} 
для преобразования числа в двоичное представление. В классе должен быть статический метод
\texttt{to\_binary} и возвращать строку с двоичным представлением числа. 
Программа также должна использовать цикл для преобразования каждого числа от 
1 до 16 и вывода результата на экран.

\subsection*{Инструкции:}
\begin{enumerate}
    \item Создайте класс \texttt{BinaryConverter}.
    \item Создайте \textbf{статический} метод \texttt{to\_binary}, который принимает число в качестве аргумента и возвращает его двоичное представление в виде строки.
    \item Используйте цикл для преобразования каждого числа от 1 до 16 (включительно), вызывая статический метод \texttt{to\_binary} и выводя результат на экран.
\end{enumerate}

\subsection*{Пример использования:}
\begin{lstlisting}[language=Python]
    v = BinaryConverter.to_binary(10)
\end{lstlisting}
Вывод (первые и последние строки):
\begin{verbatim}
1 1
2 10
3 11
...
15 1111
16 10000
\end{verbatim}

\item
Написать программу, которая создаёт класс \texttt{HexConverter} 
для преобразования числа в шестнадцатеричное представление. В классе должен быть статический метод
\texttt{to\_hex} и возвращать строку с шестнадцатеричным представлением числа. 
Программа также должна использовать цикл для преобразования каждого числа от 
1 до 20 и вывода результата на экран.

\subsection*{Инструкции:}
\begin{enumerate}
    \item Создайте класс \texttt{HexConverter}.
    \item Создайте \textbf{статический} метод \texttt{to\_hex}, который принимает число в качестве аргумента и возвращает его шестнадцатеричное представление в виде строки.
    \item Используйте цикл для преобразования каждого числа от 1 до 20 (включительно), вызывая статический метод \texttt{to\_hex} и выводя результат на экран.
\end{enumerate}

\subsection*{Пример использования:}
\begin{lstlisting}[language=Python]
    v = HexConverter.to_hex(255)
\end{lstlisting}
Вывод (первые и последние строки):
\begin{verbatim}
1 1
2 2
3 3
...
19 13
20 14
\end{verbatim}

\item
Написать программу, которая создаёт класс \texttt{DivisorChecker} 
для проверки делителей числа. В классе должен быть статический метод
\texttt{get\_divisors} и возвращать список делителей числа. 
Программа также должна использовать цикл для вывода делителей каждого числа от 
1 до 20 и вывода результата на экран.

\subsection*{Инструкции:}
\begin{enumerate}
    \item Создайте класс \texttt{DivisorChecker}.
    \item Создайте \textbf{статический} метод \texttt{get\_divisors}, который принимает число в качестве аргумента и возвращает список его делителей.
    \item Используйте цикл для вывода делителей каждого числа от 1 до 20 (включительно), вызывая статический метод \texttt{get\_divisors} и выводя результат на экран.
\end{enumerate}

\subsection*{Пример использования:}
\begin{lstlisting}[language=Python]
    v = DivisorChecker.get_divisors(12)
\end{lstlisting}
Вывод (первые и последние строки):
\begin{verbatim}
1 [1]
2 [1, 2]
3 [1, 3]
...
19 [1, 19]
20 [1, 2, 4, 5, 10, 20]
\end{verbatim}

\item
Написать программу, которая создаёт класс \texttt{Multiplier} 
для создания таблицы умножения. В классе должен быть статический метод
\texttt{multiply\_table} и выводить таблицу умножения для заданного числа. 
Программа также должна использовать цикл для вывода таблицы умножения для чисел от 
1 до 10 и вывода результата на экран.

\subsection*{Инструкции:}
\begin{enumerate}
    \item Создайте класс \texttt{Multiplier}.
    \item Создайте \textbf{статический} метод \texttt{multiply\_table}, который принимает число в качестве аргумента и выводит таблицу умножения для этого числа от 1 до 10.
    \item Используйте цикл для вывода таблицы умножения для чисел от 1 до 10 (включительно), вызывая статический метод \texttt{multiply\_table} и выводя результат на экран.
\end{enumerate}

\subsection*{Пример использования:}
\begin{lstlisting}[language=Python]
    Multiplier.multiply_table(5)
\end{lstlisting}
Вывод (для числа 5):
\begin{verbatim}
5 * 1 = 5
5 * 2 = 10
...
5 * 10 = 50
\end{verbatim}

\item
Написать программу, которая создаёт класс \texttt{GCDCalculator} 
для вычисления НОД двух чисел. В классе должен быть статический метод
\texttt{gcd} и возвращать наибольший общий делитель. 
Программа также должна использовать цикл для вычисления НОД чисел 
(1,1), (2,4), (3,9), ..., (10,100) и вывода результата на экран.

\subsection*{Инструкции:}
\begin{enumerate}
    \item Создайте класс \texttt{GCDCalculator}.
    \item Создайте \textbf{статический} метод \texttt{gcd}, который принимает два числа в качестве аргументов и возвращает их наибольший общий делитель.
    \item Используйте цикл для вычисления НОД пар чисел (1,1), (2,4), (3,9), ..., (10,100), вызывая статический метод \texttt{gcd} и выводя результат на экран.
\end{enumerate}

\subsection*{Пример использования:}
\begin{lstlisting}[language=Python]
    v = GCDCalculator.gcd(48, 18)
\end{lstlisting}
Вывод:
\begin{verbatim}
НОД(1, 1) = 1
НОД(2, 4) = 2
НОД(3, 9) = 3
...
НОД(10, 100) = 10
\end{verbatim}

\item
Написать программу, которая создаёт класс \texttt{LCMCalculator} 
для вычисления НОК двух чисел. В классе должен быть статический метод
\texttt{lcm} и возвращать наименьшее общее кратное. 
Программа также должна использовать цикл для вычисления НОК чисел 
(1,1), (2,3), (3,5), ..., (10,11) и вывода результата на экран.

\subsection*{Инструкции:}
\begin{enumerate}
    \item Создайте класс \texttt{LCMCalculator}.
    \item Создайте \textbf{статический} метод \texttt{lcm}, который принимает два числа в качестве аргументов и возвращает их наименьшее общее кратное.
    \item Используйте цикл для вычисления НОК пар чисел (1,1), (2,3), (3,5), ..., (10,11), вызывая статический метод \texttt{lcm} и выводя результат на экран.
\end{enumerate}

\subsection*{Пример использования:}
\begin{lstlisting}[language=Python]
    v = LCMCalculator.lcm(4, 6)
\end{lstlisting}
Вывод:
\begin{verbatim}
НОК(1, 1) = 1
НОК(2, 3) = 6
НОК(3, 5) = 15
...
НОК(10, 11) = 110
\end{verbatim}

\item
Написать программу, которая создаёт класс \texttt{DigitReverse} 
для разворота цифр числа. В классе должен быть статический метод
\texttt{reverse\_digits} и возвращать число с обратным порядком цифр. 
Программа также должна использовать цикл для разворота каждого числа от 
10 до 20 и вывода результата на экран.

\subsection*{Инструкции:}
\begin{enumerate}
    \item Создайте класс \texttt{DigitReverse}.
    \item Создайте \textbf{статический} метод \texttt{reverse\_digits}, который принимает число в качестве аргумента и возвращает число с обратным порядком цифр.
    \item Используйте цикл для разворота каждого числа от 10 до 20 (включительно), вызывая статический метод \texttt{reverse\_digits} и выводя результат на экран.
\end{enumerate}

\subsection*{Пример использования:}
\begin{lstlisting}[language=Python]
    v = DigitReverse.reverse_digits(123)
\end{lstlisting}
Вывод:
\begin{verbatim}
10 1
11 11
12 21
13 31
...
19 91
20 2
\end{verbatim}

\item
Написать программу, которая создаёт класс \texttt{NumberTypeChecker} 
для определения типа числа (положительное/отрицательное/ноль). В классе должен быть статический метод
\texttt{check\_number\_type} и возвращать строку с типом числа. 
Программа также должна использовать цикл для проверки чисел 
[-5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5] и вывода результата на экран.

\subsection*{Инструкции:}
\begin{enumerate}
    \item Создайте класс \texttt{NumberTypeChecker}.
    \item Создайте \textbf{статический} метод \texttt{check\_number\_type}, который принимает число в качестве аргумента и возвращает строку "positive", "negative" или "zero".
    \item Используйте цикл для проверки чисел [-5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5], вызывая статический метод \texttt{check\_number\_type} и выводя результат на экран.
\end{enumerate}

\subsection*{Пример использования:}
\begin{lstlisting}[language=Python]
    v = NumberTypeChecker.check_number_type(-7)
\end{lstlisting}
Вывод:
\begin{verbatim}
-5 negative
-4 negative
-3 negative
-2 negative
-1 negative
0 zero
1 positive
2 positive
3 positive
4 positive
5 positive
\end{verbatim}

\item
Написать программу, которая создаёт класс \texttt{FactorialChecker} 
для проверки факториала числа. В классе должен быть статический метод
\texttt{is\_factorial} и возвращать \texttt{True}, если число является факториалом какого-либо числа, 
и \texttt{False} в противном случае. 
Программа также должна использовать цикл для проверки каждого числа от 
1 до 120 и вывода результата на экран.

\subsection*{Инструкции:}
\begin{enumerate}
    \item Создайте класс \texttt{FactorialChecker}.
    \item Создайте \textbf{статический} метод \texttt{is\_factorial}, который принимает число в качестве аргумента и проверяет, является ли число факториалом какого-либо числа.
    \item Используйте цикл для проверки каждого числа от 1 до 120 (включительно), вызывая статический метод \texttt{is\_factorial} и выводя результат на экран.
\end{enumerate}

\subsection*{Пример использования:}
\begin{lstlisting}[language=Python]
    v = FactorialChecker.is_factorial(24)
\end{lstlisting}
Вывод (первые и последние строки):
\begin{verbatim}
1 True
2 True
3 False
...
119 False
120 True
\end{verbatim}

\item
Написать программу, которая создаёт класс \texttt{PowerChecker} 
для проверки степени числа. В классе должен быть статический метод
\texttt{is\_power} и возвращать \texttt{True}, если число является степенью заданного основания, 
и \texttt{False} в противном случае. 
Программа также должна использовать цикл для проверки каждого числа от 
1 до 100 относительно основания 3 и вывода результата на экран.

\subsection*{Инструкции:}
\begin{enumerate}
    \item Создайте класс \texttt{PowerChecker}.
    \item Создайте \textbf{статический} метод \texttt{is\_power}, который принимает число и основание в качестве аргументов и проверяет, является ли число степенью основания.
    \item Используйте цикл для проверки каждого числа от 1 до 100 (включительно) относительно основания 3, вызывая статический метод \texttt{is\_power} и выводя результат на экран.
\end{enumerate}

\subsection*{Пример использования:}
\begin{lstlisting}[language=Python]
    v = PowerChecker.is_power(81, 3)
\end{lstlisting}
Вывод (первые и последние строки):
\begin{verbatim}
1 True
2 False
3 True
...
99 False
100 False
\end{verbatim}

\item
Написать программу, которая создаёт класс \texttt{DigitProductCalculator} 
для вычисления произведения цифр числа. В классе должен быть статический метод
\texttt{digit\_product} и возвращать произведение цифр. 
Программа также должна использовать цикл для вычисления произведения цифр каждого числа от 
1 до 50 и вывода результата на экран.

\subsection*{Инструкции:}
\begin{enumerate}
    \item Создайте класс \texttt{DigitProductCalculator}.
    \item Создайте \textbf{статический} метод \texttt{digit\_product}, который принимает число в качестве аргумента и возвращает произведение его цифр.
    \item Используйте цикл для вычисления произведения цифр каждого числа от 1 до 50 (включительно), вызывая статический метод \texttt{digit\_product} и выводя результат на экран.
\end{enumerate}

\subsection*{Пример использования:}
\begin{lstlisting}[language=Python]
    v = DigitProductCalculator.digit_product(123)
\end{lstlisting}
Вывод (первые и последние строки):
\begin{verbatim}
1 1
2 2
3 3
...
49 36
50 0
\end{verbatim}

\item
Написать программу, которая создаёт класс \texttt{NumberLengthChecker} 
для проверки длины числа. В классе должен быть статический метод
\texttt{get\_length} и возвращать количество цифр в числе. 
Программа также должна использовать цикл для проверки длины каждого числа от 
1 до 1000 с шагом 100 и вывода результата на экран.

\subsection*{Инструкции:}
\begin{enumerate}
    \item Создайте класс \texttt{NumberLengthChecker}.
    \item Создайте \textbf{статический} метод \texttt{get\_length}, который принимает число в качестве аргумента и возвращает количество его цифр.
    \item Используйте цикл для проверки длины чисел 1, 100, 200, 300, 400, 500, 600, 700, 800, 900, 1000, вызывая статический метод \texttt{get\_length} и выводя результат на экран.
\end{enumerate}

\subsection*{Пример использования:}
\begin{lstlisting}[language=Python]
    v = NumberLengthChecker.get_length(12345)
\end{lstlisting}
Вывод:
\begin{verbatim}
1 1
100 3
200 3
300 3
400 3
500 3
600 3
700 3
800 3
900 3
1000 4
\end{verbatim}

\item
Написать программу, которая создаёт класс \texttt{NumberSquareSumCalculator} 
для вычисления суммы квадратов чисел. В классе должен быть статический метод
\texttt{square\_sum} и возвращать сумму квадратов чисел в диапазоне. 
Программа также должна использовать метод для вычисления суммы квадратов чисел от 
1 до 10 и вывода результата на экран.

\subsection*{Инструкции:}
\begin{enumerate}
    \item Создайте класс \texttt{NumberSquareSumCalculator}.
    \item Создайте \textbf{статический} метод \texttt{square\_sum}, который принимает два аргумента (начало и конец диапазона) и возвращает сумму квадратов чисел в этом диапазоне.
    \item Используйте метод для вычисления суммы квадратов чисел от 1 до 10 и выведите результат.
\end{enumerate}

\subsection*{Пример использования:}
\begin{lstlisting}[language=Python]
    v = NumberSquareSumCalculator.square_sum(1, 3)
\end{lstlisting}
Вывод:
\begin{verbatim}
Сумма квадратов чисел от 1 до 10: 385
\end{verbatim}

\item
Написать программу, которая создаёт класс \texttt{NumberCubeSumCalculator} 
для вычисления суммы кубов чисел. В классе должен быть статический метод
\texttt{cube\_sum} и возвращать сумму кубов чисел в диапазоне. 
Программа также должна использовать метод для вычисления суммы кубов чисел от 
1 до 10 и вывода результата на экран.

\subsection*{Инструкции:}
\begin{enumerate}
    \item Создайте класс \texttt{NumberCubeSumCalculator}.
    \item Создайте \textbf{статический} метод \texttt{cube\_sum}, который принимает два аргумента (начало и конец диапазона) и возвращает сумму кубов чисел в этом диапазоне.
    \item Используйте метод для вычисления суммы кубов чисел от 1 до 10 и выведите результат.
\end{enumerate}

\subsection*{Пример использования:}
\begin{lstlisting}[language=Python]
    v = NumberCubeSumCalculator.cube_sum(1, 3)
\end{lstlisting}
Вывод:
\begin{verbatim}
Сумма кубов чисел от 1 до 10: 3025
\end{verbatim}

\item
Написать программу, которая создаёт класс \texttt{NumberRangeChecker} 
для проверки числа на принадлежность диапазону. В классе должен быть статический метод
\texttt{in\_range} и возвращать \texttt{True}, если число находится в заданном диапазоне, 
и \texttt{False} в противном случае. 
Программа также должна использовать цикл для проверки чисел от 
-5 до 5 на принадлежность диапазону [0, 10] и вывода результата на экран.

\subsection*{Инструкции:}
\begin{enumerate}
    \item Создайте класс \texttt{NumberRangeChecker}.
    \item Создайте \textbf{статический} метод \texttt{in\_range}, который принимает число, начало и конец диапазона и проверяет, находится ли число в этом диапазоне.
    \item Используйте цикл для проверки чисел от -5 до 5 (включительно) на принадлежность диапазону [0, 10], вызывая статический метод \texttt{in\_range} и выводя результат на экран.
\end{enumerate}

\subsection*{Пример использования:}
\begin{lstlisting}[language=Python]
    v = NumberRangeChecker.in_range(5, 0, 10)
\end{lstlisting}
Вывод:
\begin{verbatim}
-5 False
-4 False
-3 False
-2 False
-1 False
0 True
1 True
2 True
3 True
4 True
5 True
\end{verbatim}

\item
Написать программу, которая создаёт класс \texttt{NumberSignChecker} 
для проверки знака числа. В классе должен быть статический метод
\texttt{get\_sign} и возвращать строку с знаком числа (+, - или 0). 
Программа также должна использовать цикл для проверки чисел 
[-5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5] и вывода результата на экран.

\subsection*{Инструкции:}
\begin{enumerate}
    \item Создайте класс \texttt{NumberSignChecker}.
    \item Создайте \textbf{статический} метод \texttt{get\_sign}, который принимает число в качестве аргумента и возвращает строку с его знаком (+, - или 0).
    \item Используйте цикл для проверки чисел [-5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5], вызывая статический метод \texttt{get\_sign} и выводя результат на экран.
\end{enumerate}

\subsection*{Пример использования:}
\begin{lstlisting}[language=Python]
    v = NumberSignChecker.get_sign(-7)
\end{lstlisting}
Вывод:
\begin{verbatim}
-5 -
-4 -
-3 -
-2 -
-1 -
0 0
1 +
2 +
3 +
4 +
5 +
\end{verbatim}

\item
Написать программу, которая создаёт класс \texttt{NumberPalindromeChecker} 
для проверки палиндрома числа. В классе должен быть статический метод
\texttt{is\_palindrome} и возвращать \texttt{True}, если число является палиндромом, 
и \texttt{False} в противном случае. 
Программа также должна использовать цикл для проверки каждого числа от 
100 до 150 и вывода результата на экран.

\subsection*{Инструкции:}
\begin{enumerate}
    \item Создайте класс \texttt{NumberPalindromeChecker}.
    \item Создайте \textbf{статический} метод \texttt{is\_palindrome}, который принимает число в качестве аргумента и проверяет, является ли число палиндромом.
    \item Используйте цикл для проверки каждого числа от 100 до 150 (включительно), вызывая статический метод \texttt{is\_palindrome} и выводя результат на экран.
\end{enumerate}

\subsection*{Пример использования:}
\begin{lstlisting}[language=Python]
    v = NumberPalindromeChecker.is_palindrome(121)
\end{lstlisting}
Вывод (первые и последние строки):
\begin{verbatim}
100 False
101 True
102 False
...
149 False
150 False
\end{verbatim}

\item
Написать программу, которая создаёт класс \texttt{NumberAscendingChecker} 
для проверки, что цифры числа идут в порядке возрастания. В классе должен быть статический метод
\texttt{is\_ascending} и возвращать \texttt{True}, если цифры числа идут в порядке возрастания, 
и \texttt{False} в противном случае. 
Программа также должна использовать цикл для проверки каждого числа от 
10 до 100 и вывода результата на экран.

\subsection*{Инструкции:}
\begin{enumerate}
    \item Создайте класс \texttt{NumberAscendingChecker}.
    \item Создайте \textbf{статический} метод \texttt{is\_ascending}, который принимает число в качестве аргумента и проверяет, идут ли его цифры в порядке возрастания.
    \item Используйте цикл для проверки каждого числа от 10 до 100 (включительно), вызывая статический метод \texttt{is\_ascending} и выводя результат на экран.
\end{enumerate}

\subsection*{Пример использования:}
\begin{lstlisting}[language=Python]
    v = NumberAscendingChecker.is_ascending(123)
\end{lstlisting}
Вывод (первые и последние строки):
\begin{verbatim}
10 False
11 False
12 True
13 True
...
98 False
99 False
100 False
\end{verbatim}

\item
Написать программу, которая создаёт класс \texttt{NumberDescendingChecker} 
для проверки, что цифры числа идут в порядке убывания. В классе должен быть статический метод
\texttt{is\_descending} и возвращать \texttt{True}, если цифры числа идут в порядке убывания, 
и \texttt{False} в противном случае. 
Программа также должна использовать цикл для проверки каждого числа от 
10 до 100 и вывода результата на экран.

\subsection*{Инструкции:}
\begin{enumerate}
    \item Создайте класс \texttt{NumberDescendingChecker}.
    \item Создайте \textbf{статический} метод \texttt{is\_descending}, который принимает число в качестве аргумента и проверяет, идут ли его цифры в порядке убывания.
    \item Используйте цикл для проверки каждого числа от 10 до 100 (включительно), вызывая статический метод \texttt{is\_descending} и выводя результат на экран.
\end{enumerate}

\subsection*{Пример использования:}
\begin{lstlisting}[language=Python]
    v = NumberDescendingChecker.is_descending(321)
\end{lstlisting}
Вывод (первые и последние строки):
\begin{verbatim}
10 False
11 False
12 False
13 False
...
98 True
99 True
100 False
\end{verbatim}

\item
Написать программу, которая создаёт класс \texttt{NumberPrimeDigitChecker} 
для проверки, что все цифры числа простые. В классе должен быть статический метод
\texttt{all\_digits\_prime} и возвращать \texttt{True}, если все цифры числа простые, 
и \texttt{False} в противном случае. 
Программа также должна использовать цикл для проверки каждого числа от 
10 до 100 и вывода результата на экран.

\subsection*{Инструкции:}
\begin{enumerate}
    \item Создайте класс \texttt{NumberPrimeDigitChecker}.
    \item Создайте \textbf{статический} метод \texttt{all\_digits\_prime}, который принимает число в качестве аргумента и проверяет, являются ли все его цифры простыми числами.
    \item Используйте цикл для проверки каждого числа от 10 до 100 (включительно), вызывая статический метод \texttt{all\_digits\_prime} и выводя результат на экран.
\end{enumerate}

\subsection*{Пример использования:}
\begin{lstlisting}[language=Python]
    v = NumberPrimeDigitChecker.all_digits_prime(23)
\end{lstlisting}
Вывод (первые и последние строки):
\begin{verbatim}
10 False
11 False
12 False
13 False
...
98 False
99 False
100 False
\end{verbatim}

\item
Написать программу, которая создаёт класс \texttt{NumberEvenDigitChecker} 
для проверки, что все цифры числа чётные. В классе должен быть статический метод
\texttt{all\_digits\_even} и возвравать \texttt{True}, если все цифры числа чётные, 
и \texttt{False} в противном случае. 
Программа также должна использовать цикл для проверки каждого числа от 
10 до 100 и вывода результата на экран.

\subsection*{Инструкции:}
\begin{enumerate}
    \item Создайте класс \texttt{NumberEvenDigitChecker}.
    \item Создайте \textbf{статический} метод \texttt{all\_digits\_even}, который принимает число в качестве аргумента и проверяет, являются ли все его цифры чётными.
    \item Используйте цикл для проверки каждого числа от 10 до 100 (включительно), вызывая статический метод \texttt{all\_digits\_even} и выводя результат на экран.
\end{enumerate}

\subsection*{Пример использования:}
\begin{lstlisting}[language=Python]
    v = NumberEvenDigitChecker.all_digits_even(24)
\end{lstlisting}
Вывод (первые и последние строки):
\begin{verbatim}
10 False
11 False
12 False
13 False
...
98 False
99 False
100 False
\end{verbatim}

\item
Написать программу, которая создаёт класс \texttt{NumberOddDigitChecker} 
для проверки, что все цифры числа нечётные. В классе должен быть статический метод
\texttt{all\_digits\_odd} и возвращать \texttt{True}, если все цифры числа нечётные, 
и \texttt{False} в противном случае. 
Программа также должна использовать цикл для проверки каждого числа от 
10 до 100 и вывода результата на экран.

\subsection*{Инструкции:}
\begin{enumerate}
    \item Создайте класс \texttt{NumberOddDigitChecker}.
    \item Создайте \textbf{статический} метод \texttt{all\_digits\_odd}, который принимает число в качестве аргумента и проверяет, являются ли все его цифры нечётными.
    \item Используйте цикл для проверки каждого числа от 10 до 100 (включительно), вызывая статический метод \texttt{all\_digits\_odd} и выводя результат на экран.
\end{enumerate}

\subsection*{Пример использования:}
\begin{lstlisting}[language=Python]
    v = NumberOddDigitChecker.all_digits_odd(135)
\end{lstlisting}
Вывод (первые и последние строки):
\begin{verbatim}
10 False
11 True
12 False
13 True
...
98 False
99 True
100 False
\end{verbatim}


\end{enumerate}

\textbf{Задача 3}

\begin{enumerate}

\item
Написать программу на Python, которая создает класс \texttt{Person} для представления сотрудника персонала. Класс должен содержать закрытые атрибуты \texttt{\_\_name}, \texttt{\_\_country}, \texttt{\_\_date\_of\_birth} и метод \texttt{calculate\_age}. Доступ к атрибутам только через методы-геттеры. Создать экземпляры и вывести информацию о каждом человеке.

\subsection*{Инструкции:}
\begin{enumerate}
    \item Создайте класс \texttt{Person} с методом \texttt{\_\_init\_\_}, который принимает имя, страну и дату рождения.
    \item Создайте методы-геттеры: \texttt{get\_name()}, \texttt{get\_country()}, \texttt{get\_date\_of\_birth()}.
    \item Создайте метод \texttt{calculate\_age()} для вычисления возраста.
    \item Создайте несколько экземпляров класса \texttt{Person}.
    \item Выведите данные каждого человека через методы класса.
\end{enumerate}

\subsection*{Пример использования:}
\begin{lstlisting}[caption=Пример кода]
from datetime import date

person1 = Person("Иванов Иван Иванович", "Россия", date(1946, 8, 15))
person2 = Person("Петров Сергей Александрович", "Белоруссия", date(1982, 10, 22))

print("Персона 1:")
print("Имя: ", person1.get_name())
print("Страна: ", person1.get_country())
print("Дата рождения: ", person1.get_date_of_birth())
print("Возраст: ", person1.calculate_age())

print("Персона 2:")
print("Имя: ", person2.get_name())
print("Страна: ", person2.get_country())
print("Дата рождения: ", person2.get_date_of_birth())
print("Возраст: ", person2.calculate_age())
\end{lstlisting}

\subsection*{Вывод:}
\begin{lstlisting}[caption=Ожидаемый вывод]
Персона 1:
Имя:  Иванов Иван Иванович
Страна:  Россия
Дата рождения:  1946-08-15
Возраст:  77
Персона 2:
Имя:  Петров Сергей Александрович
Страна:  Белоруссия
Дата рождения:  1982-10-22
Возраст:  41
\end{lstlisting}

% ================= Вариант 2 =================
\item
Создайте класс \texttt{Student} с закрытыми атрибутами \texttt{\_\_full\_name}, \texttt{\_\_enrollment\_date}, \texttt{\_\_major}. Реализуйте методы-геттеры и метод \texttt{study\_duration()} для вычисления количества лет с момента зачисления.

\subsection*{Инструкции:}
\begin{enumerate}
    \item Создайте класс \texttt{Student} с методом \texttt{\_\_init\_\_}.
    \item Методы-геттеры: \texttt{get\_full\_name()}, \texttt{get\_enrollment\_date()}, \texttt{get\_major()}.
    \item Метод \texttt{study\_duration()} вычисляет количество лет с зачисления.
    \item Создайте несколько экземпляров класса.
    \item Выведите данные каждого студента.
\end{enumerate}

\subsection*{Пример использования:}
\begin{lstlisting}[caption=Пример кода]
from datetime import date

student1 = Student("Сидоров Алексей", date(2018, 9, 1), "Математика")
student2 = Student("Иванова Мария", date(2021, 9, 1), "Физика")

print("Студент 1:")
print("Имя: ", student1.get_full_name())
print("Направление: ", student1.get_major())
print("Дата зачисления: ", student1.get_enrollment_date())
print("Стаж учёбы: ", student1.study_duration())

print("Студент 2:")
print("Имя: ", student2.get_full_name())
print("Направление: ", student2.get_major())
print("Дата зачисления: ", student2.get_enrollment_date())
print("Стаж учёбы: ", student2.study_duration())
\end{lstlisting}

\subsection*{Вывод:}
\begin{lstlisting}[caption=Ожидаемый вывод]
Студент 1:
Имя:  Сидоров Алексей
Направление:  Математика
Дата зачисления:  2018-09-01
Стаж учёбы:  5
Студент 2:
Имя:  Иванова Мария
Направление:  Физика
Дата зачисления:  2021-09-01
Стаж учёбы:  2
\end{lstlisting}

\item
Создайте класс \texttt{Employee} с закрытыми атрибутами \texttt{\_\_name}, \texttt{\_\_position}, \texttt{\_\_hire\_date}. Реализуйте методы-геттеры и метод \texttt{work\_experience()} для вычисления количества лет работы.

\subsection*{Инструкции:}
\begin{enumerate}
    \item Создайте класс \texttt{Employee} с методом \texttt{\_\_init\_\_}.
    \item Методы-геттеры: \texttt{get\_name()}, \texttt{get\_position()}, \texttt{get\_hire\_date()}.
    \item Метод \texttt{work\_experience()} вычисляет стаж в годах.
    \item Создайте несколько экземпляров класса.
    \item Выведите данные каждого сотрудника.
\end{enumerate}

\subsection*{Пример использования:}
\begin{lstlisting}[caption=Пример кода]
from datetime import date

emp1 = Employee("Кузнецов Дмитрий", "Инженер", date(2010, 5, 10))
emp2 = Employee("Смирнова Ольга", "Менеджер", date(2015, 8, 1))

print("Сотрудник 1:")
print("Имя: ", emp1.get_name())
print("Должность: ", emp1.get_position())
print("Дата приёма: ", emp1.get_hire_date())
print("Стаж: ", emp1.work_experience())

print("Сотрудник 2:")
print("Имя: ", emp2.get_name())
print("Должность: ", emp2.get_position())
print("Дата приёма: ", emp2.get_hire_date())
print("Стаж: ", emp2.work_experience())
\end{lstlisting}

\subsection*{Вывод:}
\begin{lstlisting}[caption=Ожидаемый вывод]
Сотрудник 1:
Имя:  Кузнецов Дмитрий
Должность:  Инженер
Дата приёма:  2010-05-10
Стаж:  17
Сотрудник 2:
Имя:  Смирнова Ольга
Должность:  Менеджер
Дата приёма:  2015-08-01
Стаж:  8
\end{lstlisting}

% ================= Вариант 4 =================
\item
Создайте класс \texttt{Book} с закрытыми атрибутами \texttt{\_\_title}, \texttt{\_\_author}, \texttt{\_\_publish\_date}. Реализуйте геттеры и метод \texttt{book\_age()} для вычисления возраста книги.

\subsection*{Инструкции:}
\begin{enumerate}
    \item Создайте класс \texttt{Book}.
    \item Методы-геттеры: \texttt{get\_title()}, \texttt{get\_author()}, \texttt{get\_publish\_date()}.
    \item Метод \texttt{book\_age()} вычисляет возраст книги.
    \item Создайте экземпляры класса.
    \item Выведите данные каждой книги.
\end{enumerate}

\subsection*{Пример использования:}
\begin{lstlisting}[caption=Пример кода]
from datetime import date

book1 = Book("Программирование на Python", "Иванов И.И.", date(2015, 3, 10))
book2 = Book("Алгебра", "Петров П.П.", date(2000, 9, 1))

print("Книга 1:")
print("Название: ", book1.get_title())
print("Автор: ", book1.get_author())
print("Дата публикации: ", book1.get_publish_date())
print("Возраст книги: ", book1.book_age())

print("Книга 2:")
print("Название: ", book2.get_title())
print("Автор: ", book2.get_author())
print("Дата публикации: ", book2.get_publish_date())
print("Возраст книги: ", book2.book_age())
\end{lstlisting}

\subsection*{Вывод:}
\begin{lstlisting}[caption=Ожидаемый вывод]
Книга 1:
Название:  Программирование на Python
Автор:  Иванов И.И.
Дата публикации:  2015-03-10
Возраст книги:  8
Книга 2:
Название:  Алгебра
Автор:  Петров П.П.
Дата публикации:  2000-09-01
Возраст книги:  23
\end{lstlisting}

% ================= Вариант 5 =================
\item
Создайте класс \texttt{Car} с закрытыми атрибутами \texttt{\_\_model}, \texttt{\_\_manufacturer}, \texttt{\_\_production\_date}. Геттеры и метод \texttt{car\_age()} для вычисления возраста автомобиля.

\subsection*{Инструкции:}
\begin{enumerate}
    \item Создайте класс \texttt{Car}.
    \item Методы-геттеры: \texttt{get\_model()}, \texttt{get\_manufacturer()}, \texttt{get\_production\_date()}.
    \item Метод \texttt{car\_age()} вычисляет возраст автомобиля.
    \item Создайте экземпляры класса.
    \item Выведите данные каждого автомобиля.
\end{enumerate}

\subsection*{Пример использования:}
\begin{lstlisting}[caption=Пример кода]
from datetime import date

car1 = Car("Camry", "Toyota", date(2012, 6, 15))
car2 = Car("Focus", "Ford", date(2018, 4, 20))

print("Автомобиль 1:")
print("Модель: ", car1.get_model())
print("Производитель: ", car1.get_manufacturer())
print("Дата выпуска: ", car1.get_production_date())
print("Возраст авто: ", car1.car_age())

print("Автомобиль 2:")
print("Модель: ", car2.get_model())
print("Производитель: ", car2.get_manufacturer())
print("Дата выпуска: ", car2.get_production_date())
print("Возраст авто: ", car2.car_age())
\end{lstlisting}

\subsection*{Вывод:}
\begin{lstlisting}[caption=Ожидаемый вывод]
Автомобиль 1:
Модель:  Camry
Производитель:  Toyota
Дата выпуска:  2012-06-15
Возраст авто:  11
Автомобиль 2:
Модель:  Focus
Производитель:  Ford
Дата выпуска:  2018-04-20
Возраст авто:  5
\end{lstlisting}

% ================= Вариант 6 =================
\item
Создайте класс \texttt{Pet} с закрытыми атрибутами \texttt{\_\_name}, \texttt{\_\_species}, \texttt{\_\_birth\_date}. Реализуйте методы-геттеры и метод \texttt{pet\_age()} для вычисления возраста питомца. Создайте несколько экземпляров и выведите их данные.

\subsection*{Инструкции:}
\begin{enumerate}
    \item Создайте класс \texttt{Pet} с методом \texttt{\_\_init\_\_}.
    \item Методы-геттеры: \texttt{get\_name()}, \texttt{get\_species()}, \texttt{get\_birth\_date()}.
    \item Метод \texttt{pet\_age()} вычисляет возраст питомца в годах.
    \item Создайте несколько экземпляров класса.
    \item Выведите данные каждого питомца через методы класса.
\end{enumerate}

\subsection*{Пример использования:}
\begin{lstlisting}[caption=Пример кода]
from datetime import date

pet1 = Pet("Барсик", "Кошка", date(2018, 5, 12))
pet2 = Pet("Рекс", "Собака", date(2015, 8, 1))

print("Питомец 1:")
print("Имя: ", pet1.get_name())
print("Вид: ", pet1.get_species())
print("Дата рождения: ", pet1.get_birth_date())
print("Возраст: ", pet1.pet_age())

print("Питомец 2:")
print("Имя: ", pet2.get_name())
print("Вид: ", pet2.get_species())
print("Дата рождения: ", pet2.get_birth_date())
print("Возраст: ", pet2.pet_age())
\end{lstlisting}

\subsection*{Вывод:}
\begin{lstlisting}[caption=Ожидаемый вывод]
Питомец 1:
Имя:  Барсик
Вид:  Кошка
Дата рождения:  2018-05-12
Возраст:  7
Питомец 2:
Имя:  Рекс
Вид:  Собака
Дата рождения:  2015-08-01
Возраст:  10
\end{lstlisting}

% ================= Вариант 7 =================
\item
Создайте класс \texttt{Membership} с закрытыми атрибутами \texttt{\_\_member\_name}, \texttt{\_\_membership\_type}, \texttt{\_\_join\_date}. Реализуйте методы-геттеры и метод \texttt{membership\_duration()} для вычисления длительности членства в годах.

\subsection*{Инструкции:}
\begin{enumerate}
    \item Создайте класс \texttt{Membership}.
    \item Методы-геттеры: \texttt{get\_member\_name()}, \texttt{get\_membership\_type()}, \texttt{get\_join\_date()}.
    \item Метод \texttt{membership\_duration()} вычисляет длительность членства в годах.
    \item Создайте несколько экземпляров.
    \item Выведите данные каждого участника.
\end{enumerate}

\subsection*{Пример использования:}
\begin{lstlisting}[caption=Пример кода]
from datetime import date

member1 = Membership("Иванов Иван", "Золотой", date(2018, 3, 15))
member2 = Membership("Петров Петр", "Серебряный", date(2020, 6, 1))

print("Член 1:")
print("Имя: ", member1.get_member_name())
print("Тип членства: ", member1.get_membership_type())
print("Дата вступления: ", member1.get_join_date())
print("Длительность членства: ", member1.membership_duration())

print("Член 2:")
print("Имя: ", member2.get_member_name())
print("Тип членства: ", member2.get_membership_type())
print("Дата вступления: ", member2.get_join_date())
print("Длительность членства: ", member2.membership_duration())
\end{lstlisting}

\subsection*{Вывод:}
\begin{lstlisting}[caption=Ожидаемый вывод]
Член 1:
Имя:  Иванов Иван
Тип членства:  Золотой
Дата вступления:  2018-03-15
Длительность членства:  5
Член 2:
Имя:  Петров Петр
Тип членства:  Серебряный
Дата вступления:  2020-06-01
Длительность членства:  3
\end{lstlisting}

% ================= Вариант 8 =================
\item
Создайте класс \texttt{Event} с закрытыми атрибутами \texttt{\_\_event\_name}, \texttt{\_\_location}, \texttt{\_\_event\_date}. Реализуйте методы-геттеры и метод \texttt{days\_until\_event()} для вычисления количества дней до события.

\subsection*{Инструкции:}
\begin{enumerate}
    \item Создайте класс \texttt{Event}.
    \item Методы-геттеры: \texttt{get\_event\_name()}, \texttt{get\_location()}, \texttt{get\_event\_date()}.
    \item Метод \texttt{days\_until\_event()} вычисляет дни до события.
    \item Создайте несколько экземпляров.
    \item Выведите данные каждого события.
\end{enumerate}

\subsection*{Пример использования:}
\begin{lstlisting}[caption=Пример кода]
from datetime import date

event1 = Event("Концерт", "Стадион", date(2025, 12, 1))
event2 = Event("Выставка", "Музей", date(2025, 11, 20))

print("Событие 1:")
print("Название: ", event1.get_event_name())
print("Место: ", event1.get_location())
print("Дата: ", event1.get_event_date())
print("Дней до события: ", event1.days_until_event())

print("Событие 2:")
print("Название: ", event2.get_event_name())
print("Место: ", event2.get_location())
print("Дата: ", event2.get_event_date())
print("Дней до события: ", event2.days_until_event())
\end{lstlisting}

\subsection*{Вывод:}
\begin{lstlisting}[caption=Ожидаемый вывод]
Событие 1:
Название:  Концерт
Место:  Стадион
Дата:  2025-12-01
Дней до события:  112
Событие 2:
Название:  Выставка
Место:  Музей
Дата:  2025-11-20
Дней до события:  101
\end{lstlisting}

% ================= Вариант 9 =================
\item
Создайте класс \texttt{Course} с закрытыми атрибутами \texttt{\_\_course\_name}, \texttt{\_\_start\_date}, \texttt{\_\_duration\_weeks}. Реализуйте методы-геттеры и метод \texttt{weeks\_elapsed()} для вычисления прошедших недель с начала курса.

\subsection*{Инструкции:}
\begin{enumerate}
    \item Создайте класс \texttt{Course}.
    \item Методы-геттеры: \texttt{get\_course\_name()}, \texttt{get\_start\_date()}, \texttt{get\_duration\_weeks()}.
    \item Метод \texttt{weeks\_elapsed()} вычисляет количество прошедших недель.
    \item Создайте несколько экземпляров.
    \item Выведите данные каждого курса.
\end{enumerate}

\subsection*{Пример использования:}
\begin{lstlisting}[caption=Пример кода]
from datetime import date

course1 = Course("Python", date(2025, 1, 1), 12)
course2 = Course("Алгебра", date(2025, 2, 1), 10)

print("Курс 1:")
print("Название: ", course1.get_course_name())
print("Дата начала: ", course1.get_start_date())
print("Продолжительность (недель): ", course1.get_duration_weeks())
print("Прошло недель: ", course1.weeks_elapsed())

print("Курс 2:")
print("Название: ", course2.get_course_name())
print("Дата начала: ", course2.get_start_date())
print("Продолжительность (недель): ", course2.get_duration_weeks())
print("Прошло недель: ", course2.weeks_elapsed())
\end{lstlisting}

\subsection*{Вывод:}
\begin{lstlisting}[caption=Ожидаемый вывод]
Курс 1:
Название:  Python
Дата начала:  2025-01-01
Продолжительность (недель):  12
Прошло недель:  36
Курс 2:
Название:  Алгебра
Дата начала:  2025-02-01
Продолжительность (недель):  10
Прошло недель:  31
\end{lstlisting}

% ================= Вариант 10 =================
\item
Создайте класс \texttt{Subscription} с закрытыми атрибутами \texttt{\_\_user}, \texttt{\_\_plan}, \texttt{\_\_start\_date}. Реализуйте методы-геттеры и метод \texttt{subscription\_age()} для вычисления возраста подписки в годах.

\subsection*{Инструкции:}
\begin{enumerate}
    \item Создайте класс \texttt{Subscription}.
    \item Методы-геттеры: \texttt{get\_user()}, \texttt{get\_plan()}, \texttt{get\_start\_date()}.
    \item Метод \texttt{subscription\_age()} вычисляет возраст подписки.
    \item Создайте несколько экземпляров.
    \item Выведите данные каждой подписки.
\end{enumerate}

\subsection*{Пример использования:}
\begin{lstlisting}[caption=Пример кода]
from datetime import date

sub1 = Subscription("Иванов И.", "Premium", date(2021, 3, 1))
sub2 = Subscription("Петров П.", "Basic", date(2022, 7, 15))

print("Подписка 1:")
print("Пользователь: ", sub1.get_user())
print("План: ", sub1.get_plan())
print("Дата начала: ", sub1.get_start_date())
print("Возраст подписки: ", sub1.subscription_age())

print("Подписка 2:")
print("Пользователь: ", sub2.get_user())
print("План: ", sub2.get_plan())
print("Дата начала: ", sub2.get_start_date())
print("Возраст подписки: ", sub2.subscription_age())
\end{lstlisting}

\subsection*{Вывод:}
\begin{lstlisting}[caption=Ожидаемый вывод]
Подписка 1:
Пользователь:  Иванов И.
План:  Premium
Дата начала:  2021-03-01
Возраст подписки:  4
Подписка 2:
Пользователь:  Петров П.
План:  Basic
Дата начала:  2022-07-15
Возраст подписки:  3
\end{lstlisting}

% ================= Вариант 11 =================
\item
Создайте класс \texttt{Flight} с закрытыми атрибутами \texttt{\_\_flight\_number}, \texttt{\_\_departure\_date}, \texttt{\_\_destination}. Реализуйте методы-геттеры и метод \texttt{days\_until\_departure()} для вычисления количества дней до вылета.

\subsection*{Инструкции:}
\begin{enumerate}
    \item Создайте класс \texttt{Flight}.
    \item Методы-геттеры: \texttt{get\_flight\_number()}, \texttt{get\_departure\_date()}, \texttt{get\_destination()}.
    \item Метод \texttt{days\_until\_departure()} вычисляет количество дней до вылета.
    \item Создайте несколько экземпляров.
    \item Выведите данные каждого рейса.
\end{enumerate}

\subsection*{Пример использования:}
\begin{lstlisting}[caption=Пример кода]
from datetime import date

flight1 = Flight("SU123", date(2025, 10, 15), "Москва")
flight2 = Flight("AF456", date(2025, 11, 1), "Париж")

print("Рейс 1:")
print("Номер: ", flight1.get_flight_number())
print("Дата вылета: ", flight1.get_departure_date())
print("Пункт назначения: ", flight1.get_destination())
print("Дней до вылета: ", flight1.days_until_departure())

print("Рейс 2:")
print("Номер: ", flight2.get_flight_number())
print("Дата вылета: ", flight2.get_departure_date())
print("Пункт назначения: ", flight2.get_destination())
print("Дней до вылета: ", flight2.days_until_departure())
\end{lstlisting}

\subsection*{Вывод:}
\begin{lstlisting}[caption=Ожидаемый вывод]
Рейс 1:
Номер:  SU123
Дата вылета:  2025-10-15
Пункт назначения:  Москва
Дней до вылета:  54
Рейс 2:
Номер:  AF456
Дата вылета:  2025-11-01
Пункт назначения:  Париж
Дней до вылета:  71
\end{lstlisting}

% ================= Вариант 12 =================
\item
Создайте класс \texttt{Project} с закрытыми атрибутами \texttt{\_\_project\_name}, \texttt{\_\_start\_date}, \texttt{\_\_deadline}. Реализуйте методы-геттеры и метод \texttt{days\_remaining()} для вычисления количества дней до завершения проекта.

\subsection*{Инструкции:}
\begin{enumerate}
    \item Создайте класс \texttt{Project}.
    \item Методы-геттеры: \texttt{get\_project\_name()}, \texttt{get\_start\_date()}, \texttt{get\_deadline()}.
    \item Метод \texttt{days\_remaining()} вычисляет дни до дедлайна.
    \item Создайте несколько экземпляров.
    \item Выведите данные каждого проекта.
\end{enumerate}

\subsection*{Пример использования:}
\begin{lstlisting}[caption=Пример кода]
from datetime import date

project1 = Project("Разработка сайта", date(2025, 9, 1), date(2025, 12, 1))
project2 = Project("Анализ данных", date(2025, 10, 1), date(2025, 11, 30))

print("Проект 1:")
print("Название: ", project1.get_project_name())
print("Дата начала: ", project1.get_start_date())
print("Дедлайн: ", project1.get_deadline())
print("Дней до завершения: ", project1.days_remaining())

print("Проект 2:")
print("Название: ", project2.get_project_name())
print("Дата начала: ", project2.get_start_date())
print("Дедлайн: ", project2.get_deadline())
print("Дней до завершения: ", project2.days_remaining())
\end{lstlisting}

\subsection*{Вывод:}
\begin{lstlisting}[caption=Ожидаемый вывод]
Проект 1:
Название:  Разработка сайта
Дата начала:  2025-09-01
Дедлайн:  2025-12-01
Дней до завершения:  101
Проект 2:
Название:  Анализ данных
Дата начала:  2025-10-01
Дедлайн:  2025-11-30
Дней до завершения:  91
\end{lstlisting}

% ================= Вариант 13 =================
\item
Создайте класс \texttt{Doctor} с закрытыми атрибутами \texttt{\_\_full\_name}, \texttt{\_\_specialty}, \texttt{\_\_birth\_date}. Реализуйте методы-геттеры и метод \texttt{calculate\_age()} для вычисления возраста врача.

\subsection*{Инструкции:}
\begin{enumerate}
    \item Создайте класс \texttt{Doctor}.
    \item Методы-геттеры: \texttt{get\_full\_name()}, \texttt{get\_specialty()}, \texttt{get\_birth\_date()}.
    \item Метод \texttt{calculate\_age()} вычисляет возраст.
    \item Создайте несколько экземпляров.
    \item Выведите данные каждого врача.
\end{enumerate}

\subsection*{Пример использования:}
\begin{lstlisting}[caption=Пример кода]
from datetime import date

doc1 = Doctor("Иванов И.И.", "Терапевт", date(1980, 5, 12))
doc2 = Doctor("Петров П.П.", "Хирург", date(1975, 8, 1))

print("Врач 1:")
print("Имя: ", doc1.get_full_name())
print("Специальность: ", doc1.get_specialty())
print("Дата рождения: ", doc1.get_birth_date())
print("Возраст: ", doc1.calculate_age())

print("Врач 2:")
print("Имя: ", doc2.get_full_name())
print("Специальность: ", doc2.get_specialty())
print("Дата рождения: ", doc2.get_birth_date())
print("Возраст: ", doc2.calculate_age())
\end{lstlisting}

\subsection*{Вывод:}
\begin{lstlisting}[caption=Ожидаемый вывод]
Врач 1:
Имя:  Иванов И.И.
Специальность:  Терапевт
Дата рождения:  1980-05-12
Возраст:  45
Врач 2:
Имя:  Петров П.П.
Специальность:  Хирург
Дата рождения:  1975-08-01
Возраст:  50
\end{lstlisting}

% ================= Вариант 14 =================
\item
Создайте класс \texttt{Patient} с закрытыми атрибутами \texttt{\_\_full\_name}, \texttt{\_\_admission\_date}, \texttt{\_\_diagnosis}. Реализуйте методы-геттеры и метод \texttt{hospital\_stay()} для вычисления количества дней пребывания в больнице.

\subsection*{Инструкции:}
\begin{enumerate}
    \item Создайте класс \texttt{Patient}.
    \item Методы-геттеры: \texttt{get\_full\_name()}, \texttt{get\_admission\_date()}, \texttt{get\_diagnosis()}.
    \item Метод \texttt{hospital\_stay()} вычисляет дни пребывания.
    \item Создайте несколько экземпляров.
    \item Выведите данные каждого пациента.
\end{enumerate}

\subsection*{Пример использования:}
\begin{lstlisting}[caption=Пример кода]
from datetime import date

patient1 = Patient("Сидоров С.С.", date(2025, 9, 1), "ОРВИ")
patient2 = Patient("Кузнецов К.К.", date(2025, 8, 28), "Грипп")

print("Пациент 1:")
print("Имя: ", patient1.get_full_name())
print("Дата госпитализации: ", patient1.get_admission_date())
print("Диагноз: ", patient1.get_diagnosis())
print("Дней в больнице: ", patient1.hospital_stay())

print("Пациент 2:")
print("Имя: ", patient2.get_full_name())
print("Дата госпитализации: ", patient2.get_admission_date())
print("Диагноз: ", patient2.get_diagnosis())
print("Дней в больнице: ", patient2.hospital_stay())
\end{lstlisting}

\subsection*{Вывод:}
\begin{lstlisting}[caption=Ожидаемый вывод]
Пациент 1:
Имя:  Сидоров С.С.
Дата госпитализации:  2025-09-01
Диагноз:  ОРВИ
Дней в больнице:  15
Пациент 2:
Имя:  Кузнецов К.К.
Дата госпитализации:  2025-08-28
Диагноз:  Грипп
Дней в больнице:  19
\end{lstlisting}

% ================= Вариант 15 =================
\item
Создайте класс \texttt{Concert} с закрытыми атрибутами \texttt{\_\_artist}, \texttt{\_\_venue}, \texttt{\_\_concert\_date}. Реализуйте методы-геттеры и метод \texttt{days\_until\_concert()}.

\subsection*{Инструкции:}
\begin{enumerate}
    \item Создайте класс \texttt{Concert}.
    \item Методы-геттеры: \texttt{get\_artist()}, \texttt{get\_venue()}, \texttt{get\_concert\_date()}.
    \item Метод \texttt{days\_until\_concert()} вычисляет дни до концерта.
    \item Создайте несколько экземпляров.
    \item Выведите данные каждого концерта.
\end{enumerate}

\subsection*{Пример использования:}
\begin{lstlisting}[caption=Пример кода]
from datetime import date

concert1 = Concert("Imagine Dragons", "Лужники", date(2025, 10, 10))
concert2 = Concert("Coldplay", "O2 Arena", date(2025, 11, 5))

print("Концерт 1:")
print("Исполнитель: ", concert1.get_artist())
print("Место: ", concert1.get_venue())
print("Дата: ", concert1.get_concert_date())
print("Дней до концерта: ", concert1.days_until_concert())

print("Концерт 2:")
print("Исполнитель: ", concert2.get_artist())
print("Место: ", concert2.get_venue())
print("Дата: ", concert2.get_concert_date())
print("Дней до концерта: ", concert2.days_until_concert())
\end{lstlisting}

\subsection*{Вывод:}
\begin{lstlisting}[caption=Ожидаемый вывод]
Концерт 1:
Исполнитель:  Imagine Dragons
Место:  Лужники
Дата:  2025-10-10
Дней до концерта:  49
Концерт 2:
Исполнитель:  Coldplay
Место:  O2 Arena
Дата:  2025-11-05
Дней до концерта:  75
\end{lstlisting}

% ================= Вариант 16 =================
\item
Создайте класс \texttt{Holiday} с закрытыми атрибутами \texttt{\_\_name}, \texttt{\_\_country}, \texttt{\_\_holiday\_date}. Реализуйте методы-геттеры и метод \texttt{days\_until\_holiday()}.

\subsection*{Инструкции:}
\begin{enumerate}
    \item Создайте класс \texttt{Holiday}.
    \item Методы-геттеры: \texttt{get\_name()}, \texttt{get\_country()}, \texttt{get\_holiday\_date()}.
    \item Метод \texttt{days\_until\_holiday()} вычисляет дни до праздника.
    \item Создайте несколько экземпляров.
    \item Выведите данные каждого праздника.
\end{enumerate}

\subsection*{Пример использования:}
\begin{lstlisting}[caption=Пример кода]
from datetime import date

holiday1 = Holiday("Новый Год", "Россия", date(2026, 1, 1))
holiday2 = Holiday("Рождество", "Германия", date(2025, 12, 25))

print("Праздник 1:")
print("Название: ", holiday1.get_name())
print("Страна: ", holiday1.get_country())
print("Дата: ", holiday1.get_holiday_date())
print("Дней до праздника: ", holiday1.days_until_holiday())

print("Праздник 2:")
print("Название: ", holiday2.get_name())
print("Страна: ", holiday2.get_country())
print("Дата: ", holiday2.get_holiday_date())
print("Дней до праздника: ", holiday2.days_until_holiday())
\end{lstlisting}

\subsection*{Вывод:}
\begin{lstlisting}[caption=Ожидаемый вывод]
Праздник 1:
Название:  Новый Год
Страна:  Россия
Дата:  2026-01-01
Дней до праздника:  83
Праздник 2:
Название:  Рождество
Страна:  Германия
Дата:  2025-12-25
Дней до праздника:  67
\end{lstlisting}
% ================= Вариант 17 =================
\item
Создайте класс \texttt{Employee} с закрытыми атрибутами \texttt{\_\_full\_name}, \texttt{\_\_position}, \texttt{\_\_hire\_date}. Реализуйте методы-геттеры и метод \texttt{years\_worked()} для вычисления стажа работы в годах.

\subsection*{Инструкции:}
\begin{enumerate}
    \item Создайте класс \texttt{Employee}.
    \item Методы-геттеры: \texttt{get\_full\_name()}, \texttt{get\_position()}, \texttt{get\_hire\_date()}.
    \item Метод \texttt{years\_worked()} вычисляет стаж в годах.
    \item Создайте несколько экземпляров.
    \item Выведите данные каждого сотрудника.
\end{enumerate}

\subsection*{Пример использования:}
\begin{lstlisting}[caption=Пример кода]
from datetime import date

emp1 = Employee("Иванов И.И.", "Менеджер", date(2015, 4, 1))
emp2 = Employee("Петров П.П.", "Разработчик", date(2018, 7, 15))

print("Сотрудник 1:")
print("Имя: ", emp1.get_full_name())
print("Должность: ", emp1.get_position())
print("Дата приема: ", emp1.get_hire_date())
print("Стаж: ", emp1.years_worked())

print("Сотрудник 2:")
print("Имя: ", emp2.get_full_name())
print("Должность: ", emp2.get_position())
print("Дата приема: ", emp2.get_hire_date())
print("Стаж: ", emp2.years_worked())
\end{lstlisting}

\subsection*{Вывод:}
\begin{lstlisting}[caption=Ожидаемый вывод]
Сотрудник 1:
Имя:  Иванов И.И.
Должность:  Менеджер
Дата приема:  2015-04-01
Стаж:  10
Сотрудник 2:
Имя:  Петров П.П.
Должность:  Разработчик
Дата приема:  2018-07-15
Стаж:  7
\end{lstlisting}

% ================= Вариант 18 =================
\item
Создайте класс \texttt{LibraryBook} с закрытыми атрибутами \texttt{\_\_title}, \texttt{\_\_author}, \texttt{\_\_publication\_date}. Реализуйте методы-геттеры и метод \texttt{book\_age()} для вычисления возраста книги.

\subsection*{Инструкции:}
\begin{enumerate}
    \item Создайте класс \texttt{LibraryBook}.
    \item Методы-геттеры: \texttt{get\_title()}, \texttt{get\_author()}, \texttt{get\_publication\_date()}.
    \item Метод \texttt{book\_age()} вычисляет возраст книги в годах.
    \item Создайте несколько экземпляров.
    \item Выведите данные каждой книги.
\end{enumerate}

\subsection*{Пример использования:}
\begin{lstlisting}[caption=Пример кода]
from datetime import date

book1 = LibraryBook("Война и мир", "Толстой", date(1869, 1, 1))
book2 = LibraryBook("Мастер и Маргарита", "Булгаков", date(1967, 5, 1))

print("Книга 1:")
print("Название: ", book1.get_title())
print("Автор: ", book1.get_author())
print("Дата публикации: ", book1.get_publication_date())
print("Возраст книги: ", book1.book_age())

print("Книга 2:")
print("Название: ", book2.get_title())
print("Автор: ", book2.get_author())
print("Дата публикации: ", book2.get_publication_date())
print("Возраст книги: ", book2.book_age())
\end{lstlisting}

\subsection*{Вывод:}
\begin{lstlisting}[caption=Ожидаемый вывод]
Книга 1:
Название:  Война и мир
Автор:  Толстой
Дата публикации:  1869-01-01
Возраст книги:  156
Книга 2:
Название:  Мастер и Маргарита
Автор:  Булгаков
Дата публикации:  1967-05-01
Возраст книги:  59
\end{lstlisting}

% ================= Вариант 19 =================
\item
Создайте класс \texttt{Vehicle} с закрытыми атрибутами \texttt{\_\_brand}, \texttt{\_\_model}, \texttt{\_\_manufacture\_date}. Реализуйте методы-геттеры и метод \texttt{vehicle\_age()}.

\subsection*{Инструкции:}
\begin{enumerate}
    \item Создайте класс \texttt{Vehicle}.
    \item Методы-геттеры: \texttt{get\_brand()}, \texttt{get\_model()}, \texttt{get\_manufacture\_date()}.
    \item Метод \texttt{vehicle\_age()} вычисляет возраст транспортного средства.
    \item Создайте несколько экземпляров.
    \item Выведите данные каждого транспортного средства.
\end{enumerate}

\subsection*{Пример использования:}
\begin{lstlisting}[caption=Пример кода]
from datetime import date

vehicle1 = Vehicle("Toyota", "Camry", date(2015, 5, 1))
vehicle2 = Vehicle("BMW", "X5", date(2018, 3, 10))

print("Транспорт 1:")
print("Марка: ", vehicle1.get_brand())
print("Модель: ", vehicle1.get_model())
print("Дата производства: ", vehicle1.get_manufacture_date())
print("Возраст: ", vehicle1.vehicle_age())

print("Транспорт 2:")
print("Марка: ", vehicle2.get_brand())
print("Модель: ", vehicle2.get_model())
print("Дата производства: ", vehicle2.get_manufacture_date())
print("Возраст: ", vehicle2.vehicle_age())
\end{lstlisting}

\subsection*{Вывод:}
\begin{lstlisting}[caption=Ожидаемый вывод]
Транспорт 1:
Марка:  Toyota
Модель:  Camry
Дата производства:  2015-05-01
Возраст:  10
Транспорт 2:
Марка:  BMW
Модель:  X5
Дата производства:  2018-03-10
Возраст:  7
\end{lstlisting}

% ================= Вариант 20 =================
\item
Создайте класс \texttt{Student} с закрытыми атрибутами \texttt{\_\_full\_name}, \texttt{\_\_enrollment\_date}, \texttt{\_\_major}. Реализуйте методы-геттеры и метод \texttt{study\_years()}.

\subsection*{Инструкции:}
\begin{enumerate}
    \item Создайте класс \texttt{Student}.
    \item Методы-геттеры: \texttt{get\_full\_name()}, \texttt{get\_enrollment\_date()}, \texttt{get\_major()}.
    \item Метод \texttt{study\_years()} вычисляет количество лет учебы.
    \item Создайте несколько экземпляров.
    \item Выведите данные каждого студента.
\end{enumerate}

\subsection*{Пример использования:}
\begin{lstlisting}[caption=Пример кода]
from datetime import date

student1 = Student("Иванов И.И.", date(2020, 9, 1), "Математика")
student2 = Student("Петров П.П.", date(2021, 9, 1), "Физика")

print("Студент 1:")
print("Имя: ", student1.get_full_name())
print("Дата зачисления: ", student1.get_enrollment_date())
print("Специальность: ", student1.get_major())
print("Лет учебы: ", student1.study_years())

print("Студент 2:")
print("Имя: ", student2.get_full_name())
print("Дата зачисления: ", student2.get_enrollment_date())
print("Специальность: ", student2.get_major())
print("Лет учебы: ", student2.study_years())
\end{lstlisting}

\subsection*{Вывод:}
\begin{lstlisting}[caption=Ожидаемый вывод]
Студент 1:
Имя:  Иванов И.И.
Дата зачисления:  2020-09-01
Специальность:  Математика
Лет учебы:  5
Студент 2:
Имя:  Петров П.П.
Дата зачисления:  2021-09-01
Специальность:  Физика
Лет учебы:  4
\end{lstlisting}

% ================= Вариант 21 =================
\item
Создайте класс \texttt{Ticket} с закрытыми атрибутами \texttt{\_\_ticket\_number}, \texttt{\_\_issue\_date}, \texttt{\_\_valid\_until}. Реализуйте методы-геттеры и метод \texttt{days\_valid()}.

\subsection*{Инструкции:}
\begin{enumerate}
    \item Создайте класс \texttt{Ticket}.
    \item Методы-геттеры: \texttt{get\_ticket\_number()}, \texttt{get\_issue\_date()}, \texttt{get\_valid\_until()}.
    \item Метод \texttt{days\_valid()} вычисляет дни до окончания действия билета.
    \item Создайте несколько экземпляров.
    \item Выведите данные каждого билета.
\end{enumerate}

\subsection*{Пример использования:}
\begin{lstlisting}[caption=Пример кода]
from datetime import date

ticket1 = Ticket("A123", date(2025, 9, 1), date(2025, 12, 1))
ticket2 = Ticket("B456", date(2025, 10, 1), date(2026, 1, 1))

print("Билет 1:")
print("Номер: ", ticket1.get_ticket_number())
print("Дата выдачи: ", ticket1.get_issue_date())
print("Действителен до: ", ticket1.get_valid_until())
print("Дней до окончания: ", ticket1.days_valid())

print("Билет 2:")
print("Номер: ", ticket2.get_ticket_number())
print("Дата выдачи: ", ticket2.get_issue_date())
print("Действителен до: ", ticket2.get_valid_until())
print("Дней до окончания: ", ticket2.days_valid())
\end{lstlisting}

\subsection*{Вывод:}
\begin{lstlisting}[caption=Ожидаемый вывод]
Билет 1:
Номер:  A123
Дата выдачи:  2025-09-01
Действителен до:  2025-12-01
Дней до окончания:  91
Билет 2:
Номер:  B456
Дата выдачи:  2025-10-01
Действителен до:  2026-01-01
Дней до окончания:  92
\end{lstlisting}

% ================= Вариант 22 =================
\item
Создайте класс \texttt{Appointment} с закрытыми атрибутами \texttt{\_\_client}, \texttt{\_\_service}, \texttt{\_\_appointment\_date}. Реализуйте методы-геттеры и метод \texttt{days\_until\_appointment()}.
\subsection*{Инструкции:}
\begin{enumerate}
    \item Создайте класс \texttt{Appointment}.
    \item Методы-геттеры: \texttt{get\_client()}, \texttt{get\_service()}, \texttt{get\_appointment\_date()}.
    \item Метод \texttt{days\_until\_appointment()} вычисляет дни до приёма.
    \item Создайте несколько экземпляров.
    \item Выведите данные каждого приёма.
\end{enumerate}

\subsection*{Пример использования:}
\begin{lstlisting}[caption=Пример кода]
from datetime import date

app1 = Appointment("Иванов И.", "Массаж", date(2025, 10, 5))
app2 = Appointment("Петров П.", "Стрижка", date(2025, 10, 15))

print("Приём 1:")
print("Клиент: ", app1.get_client())
print("Услуга: ", app1.get_service())
print("Дата: ", app1.get_appointment_date())
print("Дней до приёма: ", app1.days_until_appointment())

print("Приём 2:")
print("Клиент: ", app2.get_client())
print("Услуга: ", app2.get_service())
print("Дата: ", app2.get_appointment_date())
print("Дней до приёма: ", app2.days_until_appointment())
\end{lstlisting}

\subsection*{Вывод:}
\begin{lstlisting}[caption=Ожидаемый вывод]
Приём 1:
Клиент:  Иванов И.
Услуга:  Массаж
Дата:  2025-10-05
Дней до приёма:  44
Приём 2:
Клиент:  Петров П.
Услуга:  Стрижка
Дата:  2025-10-15
Дней до приёма:  54
\end{lstlisting}
% ================= Вариант 23 =================
\item
Создайте класс \texttt{Subscription} с закрытыми атрибутами \texttt{\_\_subscriber}, \texttt{\_\_start\_date}, \texttt{\_\_end\_date}. Реализуйте методы-геттеры и метод \texttt{days\_remaining()}.

\subsection*{Инструкции:}
\begin{enumerate}
    \item Создайте класс \texttt{Subscription}.
    \item Методы-геттеры: \texttt{get\_subscriber()}, \texttt{get\_start\_date()}, \texttt{get\_end\_date()}.
    \item Метод \texttt{days\_remaining()} вычисляет дни до окончания подписки.
    \item Создайте несколько экземпляров.
    \item Выведите данные каждой подписки.
\end{enumerate}

\subsection*{Пример использования:}
\begin{lstlisting}[caption=Пример кода]
from datetime import date

sub1 = Subscription("Иванов И.", date(2025, 1, 1), date(2025, 12, 31))
sub2 = Subscription("Петров П.", date(2025, 6, 1), date(2026, 5, 31))

print("Подписка 1:")
print("Абонент: ", sub1.get_subscriber())
print("Дата начала: ", sub1.get_start_date())
print("Дата окончания: ", sub1.get_end_date())
print("Дней до окончания: ", sub1.days_remaining())

print("Подписка 2:")
print("Абонент: ", sub2.get_subscriber())
print("Дата начала: ", sub2.get_start_date())
print("Дата окончания: ", sub2.get_end_date())
print("Дней до окончания: ", sub2.days_remaining())
\end{lstlisting}

\subsection*{Вывод:}
\begin{lstlisting}[caption=Ожидаемый вывод]
Подписка 1:
Абонент:  Иванов И.
Дата начала:  2025-01-01
Дата окончания:  2025-12-31
Дней до окончания:  113
Подписка 2:
Абонент:  Петров П.
Дата начала:  2025-06-01
Дата окончания:  2026-05-31
Дней до окончания:  245
\end{lstlisting}

% ================= Вариант 24 =================
\item
Создайте класс \texttt{MembershipCard} с закрытыми атрибутами \texttt{\_\_owner}, \texttt{\_\_issue\_date}, \texttt{\_\_expiry\_date}. Реализуйте методы-геттеры и метод \texttt{days\_until\_expiry()}.

\subsection*{Инструкции:}
\begin{enumerate}
    \item Создайте класс \texttt{MembershipCard}.
    \item Методы-геттеры: \texttt{get\_owner()}, \texttt{get\_issue\_date()}, \texttt{get\_expiry\_date()}.
    \item Метод \texttt{days\_until\_expiry()} вычисляет дни до истечения действия карты.
    \item Создайте несколько экземпляров.
    \item Выведите данные каждой карты.
\end{enumerate}

\subsection*{Пример использования:}
\begin{lstlisting}[caption=Пример кода]
from datetime import date

card1 = MembershipCard("Иванов И.", date(2025, 1, 1), date(2026, 1, 1))
card2 = MembershipCard("Петров П.", date(2025, 5, 1), date(2026, 5, 1))

print("Карта 1:")
print("Владелец: ", card1.get_owner())
print("Дата выдачи: ", card1.get_issue_date())
print("Срок действия: ", card1.get_expiry_date())
print("Дней до окончания: ", card1.days_until_expiry())

print("Карта 2:")
print("Владелец: ", card2.get_owner())
print("Дата выдачи: ", card2.get_issue_date())
print("Срок действия: ", card2.get_expiry_date())
print("Дней до окончания: ", card2.days_until_expiry())
\end{lstlisting}

\subsection*{Вывод:}
\begin{lstlisting}[caption=Ожидаемый вывод]
Карта 1:
Владелец:  Иванов И.
Дата выдачи:  2025-01-01
Срок действия:  2026-01-01
Дней до окончания:  113
Карта 2:
Владелец:  Петров П.
Дата выдачи:  2025-05-01
Срок действия:  2026-05-01
Дней до окончания:  204
\end{lstlisting}

% ================= Вариант 25 =================
\item
Создайте класс \texttt{Event} с закрытыми атрибутами \texttt{\_\_title}, \texttt{\_\_location}, \texttt{\_\_event\_date}. Реализуйте методы-геттеры и метод \texttt{days\_until\_event()}.

\subsection*{Инструкции:}
\begin{enumerate}
    \item Создайте класс \texttt{Event}.
    \item Методы-геттеры: \texttt{get\_title()}, \texttt{get\_location()}, \texttt{get\_event\_date()}.
    \item Метод \texttt{days\_until\_event()} вычисляет дни до события.
    \item Создайте несколько экземпляров.
    \item Выведите данные каждого события.
\end{enumerate}

\subsection*{Пример использования:}
\begin{lstlisting}[caption=Пример кода]
from datetime import date

event1 = Event("Фестиваль науки", "Москва", date(2025, 10, 20))
event2 = Event("Конференция IT", "Санкт-Петербург", date(2025, 11, 10))

print("Событие 1:")
print("Название: ", event1.get_title())
print("Место: ", event1.get_location())
print("Дата: ", event1.get_event_date())
print("Дней до события: ", event1.days_until_event())

print("Событие 2:")
print("Название: ", event2.get_title())
print("Место: ", event2.get_location())
print("Дата: ", event2.get_event_date())
print("Дней до события: ", event2.days_until_event())
\end{lstlisting}

\subsection*{Вывод:}
\begin{lstlisting}[caption=Ожидаемый вывод]
Событие 1:
Название:  Фестиваль науки
Место:  Москва
Дата:  2025-10-20
Дней до события:  59
Событие 2:
Название:  Конференция IT
Место:  Санкт-Петербург
Дата:  2025-11-10
Дней до события:  80
\end{lstlisting}

% ================= Вариант 26 =================
\item
Создайте класс \texttt{CarRental} с закрытыми атрибутами \texttt{\_\_client}, \texttt{\_\_rental\_date}, \texttt{\_\_return\_date}. Реализуйте методы-геттеры и метод \texttt{rental\_duration()}.

\subsection*{Инструкции:}
\begin{enumerate}
    \item Создайте класс \texttt{CarRental}.
    \item Методы-геттеры: \texttt{get\_client()}, \texttt{get\_rental\_date()}, \texttt{get\_return\_date()}.
    \item Метод \texttt{rental\_duration()} вычисляет длительность аренды в днях.
    \item Создайте несколько экземпляров.
    \item Выведите данные каждой аренды.
\end{enumerate}

\subsection*{Пример использования:}
\begin{lstlisting}[caption=Пример кода]
from datetime import date

rental1 = CarRental("Иванов И.", date(2025, 10, 1), date(2025, 10, 10))
rental2 = CarRental("Петров П.", date(2025, 11, 1), date(2025, 11, 5))

print("Аренда 1:")
print("Клиент: ", rental1.get_client())
print("Дата аренды: ", rental1.get_rental_date())
print("Дата возврата: ", rental1.get_return_date())
print("Длительность аренды: ", rental1.rental_duration())

print("Аренда 2:")
print("Клиент: ", rental2.get_client())
print("Дата аренды: ", rental2.get_rental_date())
print("Дата возврата: ", rental2.get_return_date())
print("Длительность аренды: ", rental2.rental_duration())
\end{lstlisting}

\subsection*{Вывод:}
\begin{lstlisting}[caption=Ожидаемый вывод]
Аренда 1:
Клиент:  Иванов И.
Дата аренды:  2025-10-01
Дата возврата:  2025-10-10
Длительность аренды:  9
Аренда 2:
Клиент:  Петров П.
Дата аренды:  2025-11-01
Дата возврата:  2025-11-05
Длительность аренды:  4
\end{lstlisting}

% ================= Вариант 27 =================
\item
Создайте класс \texttt{Visa} с закрытыми атрибутами \texttt{\_\_holder}, \texttt{\_\_issue\_date}, \texttt{\_\_expiry\_date}. Реализуйте методы-геттеры и метод \texttt{days\_until\_expiry()}.

\subsection*{Инструкции:}
\begin{enumerate}
    \item Создайте класс \texttt{Visa}.
    \item Методы-геттеры: \texttt{get\_holder()}, \texttt{get\_issue\_date()}, \texttt{get\_expiry\_date()}.
    \item Метод \texttt{days\_until\_expiry()} вычисляет дни до окончания визы.
    \item Создайте несколько экземпляров.
    \item Выведите данные каждой визы.
\end{enumerate}

\subsection*{Пример использования:}
\begin{lstlisting}[caption=Пример кода]
from datetime import date

visa1 = Visa("Иванов И.", date(2025, 1, 1), date(2026, 1, 1))
visa2 = Visa("Петров П.", date(2025, 6, 1), date(2026, 6, 1))

print("Виза 1:")
print("Держатель: ", visa1.get_holder())
print("Дата выдачи: ", visa1.get_issue_date())
print("Дата окончания: ", visa1.get_expiry_date())
print("Дней до окончания: ", visa1.days_until_expiry())

print("Виза 2:")
print("Держатель: ", visa2.get_holder())
print("Дата выдачи: ", visa2.get_issue_date())
print("Дата окончания: ", visa2.get_expiry_date())
print("Дней до окончания: ", visa2.days_until_expiry())
\end{lstlisting}

\subsection*{Вывод:}
\begin{lstlisting}[caption=Ожидаемый вывод]
Виза 1:
Держатель:  Иванов И.
Дата выдачи:  2025-01-01
Дата окончания:  2026-01-01
Дней до окончания:  113
Виза 2:
Держатель:  Петров П.
Дата выдачи:  2025-06-01
Дата окончания:  2026-06-01
Дней до окончания:  204
\end{lstlisting}

% ================= Вариант 28 =================
\item
Создайте класс \texttt{Reservation} с закрытыми атрибутами \texttt{\_\_guest}, \texttt{\_\_checkin\_date}, \texttt{\_\_checkout\_date}. Реализуйте методы-геттеры и метод \texttt{stay\_duration()}.

\subsection*{Инструкции:}
\begin{enumerate}
    \item Создайте класс \texttt{Reservation}.
    \item Методы-геттеры: \texttt{get\_guest()}, \texttt{get\_checkin\_date()}, \texttt{get\_checkout\_date()}.
    \item Метод \texttt{stay\_duration()} вычисляет продолжительность пребывания в днях.
    \item Создайте несколько экземпляров.
    \item Выведите данные каждой брони.
\end{enumerate}

\subsection*{Пример использования:}
\begin{lstlisting}[caption=Пример кода]
from datetime import date

res1 = Reservation("Иванов И.", date(2025, 10, 1), date(2025, 10, 7))
res2 = Reservation("Петров П.", date(2025, 11, 5), date(2025, 11, 12))

print("Бронь 1:")
print("Гость: ", res1.get_guest())
print("Дата заезда: ", res1.get_checkin_date())
print("Дата выезда: ", res1.get_checkout_date())
print("Продолжительность пребывания: ", res1.stay_duration())

print("Бронь 2:")
print("Гость: ", res2.get_guest())
print("Дата заезда: ", res2.get_checkin_date())
print("Дата выезда: ", res2.get_checkout_date())
print("Продолжительность пребывания: ", res2.stay_duration())
\end{lstlisting}

\subsection*{Вывод:}
\begin{lstlisting}[caption=Ожидаемый вывод]
Бронь 1:
Гость:  Иванов И.
Дата заезда:  2025-10-01
Дата выезда:  2025-10-07
Продолжительность пребывания:  6
Бронь 2:
Гость:  Петров П.
Дата заезда:  2025-11-05
Дата выезда:  2025-11-12
Продолжительность пребывания:  7
\end{lstlisting}

% ================= Вариант 29 =================
\item
Создайте класс \texttt{Conference} с закрытыми атрибутами \texttt{\_\_name}, \texttt{\_\_city}, \texttt{\_\_start\_date}. Реализуйте методы-геттеры и метод \texttt{days\_until\_start()}.

\subsection*{Инструкции:}
\begin{enumerate}
    \item Создайте класс \texttt{Conference}.
    \item Методы-геттеры: \texttt{get\_name()}, \texttt{get\_city()}, \texttt{get\_start\_date()}.
    \item Метод \texttt{days\_until\_start()} вычисляет дни до начала конференции.
    \item Создайте несколько экземпляров.
    \item Выведите данные каждой конференции.
\end{enumerate}

\subsection*{Пример использования:}
\begin{lstlisting}[caption=Пример кода]
from datetime import date

conf1 = Conference("PythonConf", "Москва", date(2025, 10, 20))
conf2 = Conference("DataScience Summit", "Санкт-Петербург", date(2025, 11, 15))

print("Конференция 1:")
print("Название: ", conf1.get_name())
print("Город: ", conf1.get_city())
print("Дата начала: ", conf1.get_start_date())
print("Дней до начала: ", conf1.days_until_start())

print("Конференция 2:")
print("Название: ", conf2.get_name())
print("Город: ", conf2.get_city())
print("Дата начала: ", conf2.get_start_date())
print("Дней до начала: ", conf2.days_until_start())
\end{lstlisting}

\subsection*{Вывод:}
\begin{lstlisting}[caption=Ожидаемый вывод]
Конференция 1:
Название:  PythonConf
Город:  Москва
Дата начала:  2025-10-20
Дней до начала:  59
Конференция 2:
Название:  DataScience Summit
Город:  Санкт-Петербург
Дата начала:  2025-11-15
Дней до начала:  85
\end{lstlisting}

% ================= Вариант 30 =================
\item
Создайте класс \texttt{Medication} с закрытыми атрибутами \texttt{\_\_name}, \texttt{\_\_manufacturer}, \texttt{\_\_expiry\_date}. Реализуйте методы-геттеры и метод \texttt{days\_until\_expiry()}.

\subsection*{Инструкции:}
\begin{enumerate}
    \item Создайте класс \texttt{Medication}.
    \item Методы-геттеры: \texttt{get\_name()}, \texttt{get\_manufacturer()}, \texttt{get\_expiry\_date()}.
    \item Метод \texttt{days\_until\_expiry()} вычисляет дни до окончания срока годности.
    \item Создайте несколько экземпляров.
    \item Выведите данные каждого лекарства.
\end{enumerate}

\subsection*{Пример использования:}
\begin{lstlisting}[caption=Пример кода]
from datetime import date

med1 = Medication("Парацетамол", "Фармком", date(2026, 1, 1))
med2 = Medication("Ибупрофен", "БиоФарм", date(2025, 12, 1))

print("Лекарство 1:")
print("Название: ", med1.get_name())
print("Производитель: ", med1.get_manufacturer())
print("Срок годности: ", med1.get_expiry_date())
print("Дней до окончания: ", med1.days_until_expiry())

print("Лекарство 2:")
print("Название: ", med2.get_name())
print("Производитель: ", med2.get_manufacturer())
print("Срок годности: ", med2.get_expiry_date())
print("Дней до окончания: ", med2.days_until_expiry())
\end{lstlisting}

\subsection*{Вывод:}
\begin{lstlisting}[caption=Ожидаемый вывод]
Лекарство 1:
Название:  Парацетамол
Производитель:  Фармком
Срок годности:  2026-01-01
Дней до окончания:  113
Лекарство 2:
Название:  Ибупрофен
Производитель:  БиоФарм
Срок годности:  2025-12-01
Дней до окончания:  92
\end{lstlisting}

% ================= Вариант 31 =================
\item
Создайте класс \texttt{Project} с закрытыми атрибутами \texttt{\_\_title}, \texttt{\_\_start\_date}, \texttt{\_\_deadline}. Реализуйте методы-геттеры и метод \texttt{days\_until\_deadline()}.

\subsection*{Инструкции:}
\begin{enumerate}
    \item Создайте класс \texttt{Project}.
    \item Методы-геттеры: \texttt{get\_title()}, \texttt{get\_start\_date()}, \texttt{get\_deadline()}.
    \item Метод \texttt{days\_until\_deadline()} вычисляет дни до дедлайна.
    \item Создайте несколько экземпляров.
    \item Выведите данные каждого проекта.
\end{enumerate}

\subsection*{Пример использования:}
\begin{lstlisting}[caption=Пример кода]
from datetime import date

proj1 = Project("Разработка сайта", date(2025, 9, 1), date(2025, 12, 1))
proj2 = Project("Мобильное приложение", date(2025, 10, 1), date(2026, 1, 15))

print("Проект 1:")
print("Название: ", proj1.get_title())
print("Дата начала: ", proj1.get_start_date())
print("Дедлайн: ", proj1.get_deadline())
print("Дней до дедлайна: ", proj1.days_until_deadline())

print("Проект 2:")
print("Название: ", proj2.get_title())
print("Дата начала: ", proj2.get_start_date())
print("Дедлайн: ", proj2.get_deadline())
print("Дней до дедлайна: ", proj2.days_until_deadline())
\end{lstlisting}

\subsection*{Вывод:}
\begin{lstlisting}[caption=Ожидаемый вывод]
Проект 1:
Название:  Разработка сайта
Дата начала:  2025-09-01
Дедлайн:  2025-12-01
Дней до дедлайна:  91
Проект 2:
Название:  Мобильное приложение
Дата начала:  2025-10-01
Дедлайн:  2026-01-15
Дней до дедлайна:  106
\end{lstlisting}


\end{enumerate}


\textbf{Задача 4}

\input{problem_inheritence_task4}